//***********************************************************************************************
//  This example shows how to use the basic methods of the FluxGarage Robo Eyes library. 
//
//  Hardware: You'll need a breadboard, an arduino nano r3, an I2C oled display with 1306   
//  or 1309 chip and some jumper wires.
//  
//  Published in September 2024 by Dennis Hoelscher, FluxGarage
//  www.youtube.com/@FluxGarage
//  www.fluxgarage.com
//
//***********************************************************************************************


#include <Adafruit_SSD1306.h>
#include <FluxGarage_RoboEyes.h>
#include <RTClib.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)

const int BUTTON_PIN = 32;
const int MIC_PIN = 35; // Connect MAX9814 OUT to 35
const int VIBE_PIN = 18; // New Vibration Pin

int count = 0;
struct touchEvent { 
	 byte wasPressed = LOW; 
	 byte isPressed = LOW; 
}; 
touchEvent touch; 

// --- AUDIO SETTINGS ---
unsigned long scareTimer = 0; 
bool isScared = false;

// SENSITIVITY SETTING
// For MAX9814, a clap usually creates a spike > 200 or 300.
// If it triggers too easily, increase this number (e.g., 500).
// If it doesn't trigger, decrease it (e.g., 150).
int noiseThreshold = 2000;

// --- RTC CLOCK VARIABLES ---
RTC_DS1307 rtc; 
bool isSleeping = false;
unsigned long wakeUpOverrideTimer = 0;

// NEW: Master Override for "Work Mode"
bool forceAwake = false;

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// create a RoboEyes instance using an Adafruit_SSD1306 display driver
RoboEyes<Adafruit_SSD1306> roboEyes(display); 


void setup() {

  pinMode(BUTTON_PIN, INPUT); 
  pinMode(MIC_PIN, INPUT);
  pinMode(VIBE_PIN, OUTPUT);

  Serial.begin(115200);

  // *** FIX 1: SPEED UP THE SCREEN ***
  // This makes the I2C bus run at 400kHz instead of 100kHz.
  // This reduces the time the robot is "deaf" while drawing eyes.
  Wire.begin();
  Wire.setClock(400000);

  // Startup OLED Display
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C or 0x3D
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // 4. Start Clock
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
  }

  // Startup robo eyes
  roboEyes.begin(SCREEN_WIDTH, SCREEN_HEIGHT, 100); // screen-width, screen-height, max framerate

  // Define some automated eyes behaviour
  //roboEyes.setAutoblinker(ON, 3, 2); // Start auto blinker animation cycle -> bool active, int interval, int variation -> turn on/off, set interval between each blink in full seconds, set range for random interval variation in full seconds
  //roboEyes.setIdleMode(ON, 2, 2); // Start idle animation cycle (eyes looking in random directions) -> turn on/off, set interval between each eye repositioning in full seconds, set range for random time interval variation in full seconds
  
  // Define eye shapes, all values in pixels
  //roboEyes.setWidth(36, 36); // byte leftEye, byte rightEye
  //roboEyes.setHeight(36, 36); // byte leftEye, byte rightEye
  //roboEyes.setBorderradius(8, 8); // byte leftEye, byte rightEye
  //roboEyes.setSpacebetween(10); // int space -> can also be negative

  // Cyclops mode
  //roboEyes.setCyclops(ON); // bool on/off -> if turned on, robot has only on eye

  // Define mood, curiosity and position
  roboEyes.setMood(DEFAULT); // mood expressions, can be TIRED, ANGRY, HAPPY, DEFAULT
  roboEyes.setPosition(DEFAULT); // cardinal directions, can be N, NE, E, SE, S, SW, W, NW, DEFAULT (default = horizontally and vertically centered)
  roboEyes.setCuriosity(ON); // bool on/off -> when turned on, height of the outer eyes increases when moving to the very left or very right
  roboEyes.setSweat(ON);
  // Set horizontal or vertical flickering
  //roboEyes.setHFlicker(ON, 2); // bool on/off, byte amplitude -> horizontal flicker: alternately displacing the eyes in the defined amplitude in pixels
  //roboEyes.setVFlicker(ON, 2); // bool on/off, byte amplitude -> vertical flicker: alternately displacing the eyes in the defined amplitude in pixels

  // Play prebuilt oneshot animations
  //roboEyes.anim_confused(); // confused - eyes shaking left and right
  roboEyes.anim_laugh(); // laughing - eyes shaking up and down
  
} // end of setup


void loop() {
  roboEyes.update(); // update eyes drawings

  // --- 2. CHECK FOR SERIAL COMMANDS ("wake" / "sleep") ---
  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim(); // Remove whitespace

    if (command == "wake") {
      forceAwake = true;
      Serial.println("COMMAND: FORCE AWAKE! (Ignoring Time)");
      // Optional: Visual feedback
      roboEyes.setMood(HAPPY);
      roboEyes.open();
    }
    else if (command == "sleep") { // Meaning "Return to Auto Routine"
      forceAwake = false;
      Serial.println("COMMAND: AUTO MODE (Checking Clock)");
    }
  }

  DateTime now = rtc.now();
  int currentHour = now.hour();

  //Serial.println("Current hour: ");
  //Serial.println(currentHour);
  // --- TIME LOGIC ---
  bool overrideActive = (millis() - wakeUpOverrideTimer < 10000);

  // LOGIC: Sleep ONLY if:
  // 1. It is Night Time (23-7)
  // 2. AND we are NOT forced awake by Serial ("wake")
  // 3. AND we are NOT forced awake by Button
  // 4. AND we are NOT scared  
  if ((currentHour >= 23 || currentHour < 7) && !forceAwake && !overrideActive && !isScared) {
     if (!isSleeping) {
       isSleeping = true;
       roboEyes.setIdleMode(OFF);
       roboEyes.setAutoblinker(OFF);
       Serial.println("Status: Sleeping (Night Time)");
     }
     roboEyes.close(); 
     
  }
  // TIRED at 10 PM (22)
  else if (currentHour == 22 && !overrideActive && !isScared) {
     isSleeping = false;
     roboEyes.setMood(TIRED);
     Serial.println("Status: Tired (About Sleeping)");
  }
  // WAKE UP / NORMAL
  else {
     if (isSleeping) {
       isSleeping = false;
       roboEyes.setMood(HAPPY);
       roboEyes.open();
       roboEyes.setIdleMode(ON, 2, 2);
       Serial.println("Status: Waking Up");
     }
  }

  // --- 1. MICROPHONE LOGIC ---
  // Only listen for noise if we are NOT currently scared (to prevent resetting the timer constantly)
  if (!isScared) {
    int currentVolume = getLoudness();

    if (currentVolume > noiseThreshold) {
      Serial.print("LOUD NOISE: ");
      Serial.println(currentVolume);
      
      roboEyes.setMood(SCARY); 
      isScared = true;
      scareTimer = millis();
      vibrate(2); // NEW: Shake with fear! 
    }
  }

  // Timer to calm down after 2 seconds
  if (isScared && millis() - scareTimer > 2000) { 
    Serial.println("Calming down...");
    roboEyes.setMood(DEFAULT); 
    isScared = false;
  }

  // --- 2. BUTTON LOGIC ---
  touch.isPressed = isTouchPressed(BUTTON_PIN);

  // FIX: Check if state changed AND the button is actually pressed (HIGH)
  if (touch.wasPressed != touch.isPressed && touch.isPressed == HIGH) {
    
    // *** NEW LINE: Tell the time logic to pause for 10 seconds ***
    wakeUpOverrideTimer = millis();

    Serial.println("Touch pressed");
    count += 1;
    Serial.println("Count:");
    Serial.println(count);

    // Reset count if it gets too high (Optional, keeps it cycling)
    if (count > 5) count = 1; 

    if (count == 1) {
      roboEyes.setMood(HAPPY);
      Serial.println("HAPPY");
    } 
    else if(count == 2) {
      // Note: You had Happy twice in your code, assuming intended
      roboEyes.setMood(TIRED);
      Serial.println("TIRED");
    } 
    else if(count == 3) {
      roboEyes.setMood(ANGRY);
      Serial.println("ANGRY");
      vibrate(1); // NEW: Annoyed Buzz
    } 
    else if(count == 4) {
      roboEyes.setMood(FROZEN);
      Serial.println("FROZEN");
    } 
    else {
      roboEyes.setMood(SCARY);
      Serial.println("SCARY");
    }
  }

  // Update the previous state for the next loop
  touch.wasPressed = touch.isPressed;
}

bool isTouchPressed(int pin) 
{ 
	 return digitalRead(pin) == HIGH; 
} 

// Function to calculate Peak-to-Peak Amplitude
int getLoudness() {
  unsigned long startMillis = millis(); 
  unsigned int signalMax = 0;
  unsigned int signalMin = 4095;

  // *** FIX 2: SHORTER WINDOW ***
  // Reduced from 50ms to 30ms. 
  // This makes the loop repeat faster, so it feels more "responsive"
  unsigned int sampleWindow = 30; // Listen for 30ms

  // Collect data
  while (millis() - startMillis < sampleWindow) {
    int sample = analogRead(MIC_PIN);
    
    if (sample < 4095) {  
      if (sample > signalMax) {
        signalMax = sample;  
      }
      else if (sample < signalMin) {
        signalMin = sample;  
      }
    }
  }
  // Return the difference between the highest and lowest reading
  return signalMax - signalMin; 
}

// pattern 1 = Short Buzz (Annoyed)
// pattern 2 = Long Shake (Scared)
// pattern 3 = Heartbeat (Love/Happy)
void vibrate(int pattern) {
  if (pattern == 1) {
    digitalWrite(VIBE_PIN, HIGH);
    delay(400);
    digitalWrite(VIBE_PIN, LOW);
  }
  else if (pattern == 2) {
    // Shaking Effect
    for(int i=0; i<5; i++){
      digitalWrite(VIBE_PIN, HIGH);
      delay(250);
      digitalWrite(VIBE_PIN, LOW);
      delay(100);
    }
  }
  else if (pattern == 3) {
    // Heartbeat: Thump-Thump... Thump-Thump
    digitalWrite(VIBE_PIN, HIGH); delay(150);
    digitalWrite(VIBE_PIN, LOW);  delay(100);
    digitalWrite(VIBE_PIN, HIGH); delay(150);
    digitalWrite(VIBE_PIN, LOW);
  }
}
